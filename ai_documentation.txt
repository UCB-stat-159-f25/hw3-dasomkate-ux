Question: # make wav (sound) files from the whitened data, +-2s around the event. from scipy.io import wavfile # function to keep the data within integer limits, and write to wavfile: def write_wavfile(filename,fs,data): d = np.int16(data/np.max(np.abs(data)) * 32767 * 0.9) wavfile.write(filename,int(fs), d) deltat_sound = 2. # seconds around the event # index into the strain time series for this time interval: indxd = np.where((time >= tevent-deltat_sound) & (time < tevent+deltat_sound)) # write the files: write_wavfile('audio/'+eventname+"_H1_whitenbp.wav",int(fs), strain_H1_whitenbp[indxd]) write_wavfile('audio/'+eventname+"_L1_whitenbp.wav",int(fs), strain_L1_whitenbp[indxd]) # re-whiten the template using the smoothed PSD; it sounds better! template_p_smooth = whiten(template_p,psd_smooth,dt) # and the template, sooming in on [-3,+1] seconds around the merger: indxt = np.where((time >= (time[0]+template_offset-deltat_sound)) & (time < (time[0]+template_offset+deltat_sound))) write_wavfile('audio/'+eventname+"_template_whiten.wav",int(fs), template_p_smooth[indxt]) which part of this is the actual function

Answer: The only actual function definition in this code is:
def write_wavfile(filename, fs, data):
    d = np.int16(data / np.max(np.abs(data)) * 32767 * 0.9)
    wavfile.write(filename, int(fs), d)


That’s the only reusable function — it defines a procedure you can call elsewhere.

Everything else in your snippet (the variables like deltat_sound, indxd, and the calls to write_wavfile(...)) are script code — code that executes immediately when you run the file.